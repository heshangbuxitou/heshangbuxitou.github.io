<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<!-- 加载gitment的css和js文件 -->
<link rel="stylesheet" href="/css/gitment.css"> 
<script src="/js/gitment.js"></script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Servlet,IO,异步事件模型," />










<meta name="description" content="了解Java NIONIO最早出现在JDK1.4中，NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I/O 包所无法做到的。 NIO带来的好处NIO的创建目的是为了让Java程序员可以实现高速I/O而无需编写自定义的本机代码。NIO将最耗时的">
<meta name="keywords" content="Servlet,IO,异步事件模型">
<meta property="og:type" content="article">
<meta property="og:title" content="Java NIO详解">
<meta property="og:url" content="https://heshangbuxitou.github.io/2018/01/08/Java-NIOdetailed/index.html">
<meta property="og:site_name" content="SiYuYong&#39;s Blog">
<meta property="og:description" content="了解Java NIONIO最早出现在JDK1.4中，NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I/O 包所无法做到的。 NIO带来的好处NIO的创建目的是为了让Java程序员可以实现高速I/O而无需编写自定义的本机代码。NIO将最耗时的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a548450770c6.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a5484507fdc3.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a54845087b13.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a54845087b98.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a54845087b52.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a548450881b2.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a54845088770.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a5484508c6f3.gif">
<meta property="og:image" content="https://i.loli.net/2018/01/09/5a5484508c6f3.gif">
<meta property="og:updated_time" content="2018-01-26T06:26:07.544Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java NIO详解">
<meta name="twitter:description" content="了解Java NIONIO最早出现在JDK1.4中，NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I/O 包所无法做到的。 NIO带来的好处NIO的创建目的是为了让Java程序员可以实现高速I/O而无需编写自定义的本机代码。NIO将最耗时的">
<meta name="twitter:image" content="https://i.loli.net/2018/01/09/5a548450770c6.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://heshangbuxitou.github.io/2018/01/08/Java-NIOdetailed/"/>





<meta name="google-site-verification" content="3CjstPVfqGKNYOswM2Dl407aZWDTievG6ytMf7zpXZI" />
<meta name="baidu-site-verification" content="KPNc5qApqS" />

  <title>Java NIO详解 | SiYuYong's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SiYuYong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://heshangbuxitou.github.io/2018/01/08/Java-NIOdetailed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SiYuYong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myavatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SiYuYong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java NIO详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-08T22:06:03+08:00">
                2018-01-08
              </time>
            

            

            
          </span>



          

          
            <span id="busuanzi_container_page_pv">&nbsp;&nbsp;|&nbsp;&nbsp;阅读量 <span id="busuanzi_value_page_pv"
            ></span> 次</span>
          

          
            
          


          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="了解Java-NIO"><a href="#了解Java-NIO" class="headerlink" title="了解Java NIO"></a>了解Java NIO</h1><p>NIO最早出现在JDK1.4中，NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I/O 包所无法做到的。</p>
<h2 id="NIO带来的好处"><a href="#NIO带来的好处" class="headerlink" title="NIO带来的好处"></a>NIO带来的好处</h2><p>NIO的创建目的是为了让Java程序员可以实现高速I/O而无需编写自定义的本机代码。NIO将最耗时的I/O操作(即填充和提取缓冲区)转移回操作系统，背后可以采用基于操作系统底层的IO读取模型，因而可以极大地提高速度。</p>
<h2 id="NIO与传统的IO有什么不同"><a href="#NIO与传统的IO有什么不同" class="headerlink" title="NIO与传统的IO有什么不同"></a>NIO与传统的IO有什么不同</h2><p>原来的I/O库(在 java.io.*中)与NIO最重要的区别是数据打包和传输的方式。正如前面提到的，原来的I/O以流的方式处理数据，而NIO以块的方式处理数据。<br>面向流的I/O系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的I/O通常相当慢。<br>一个面向块的I/O系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的I/O缺少一些面向流的I/O所具有的优雅性和简单性。</p>
<h1 id="NIO的核心"><a href="#NIO的核心" class="headerlink" title="NIO的核心"></a>NIO的核心</h1><p><strong>通道</strong>和<strong>缓冲</strong>是NIO的核心，<strong>通道</strong>可以看作是IO包中的流的模拟，当需要获取或者写入数据时，需要通过Channel对象传入或者传出，中间使用Buffer等的缓冲区，Buffer对象实质上是一个容器对象，发给<strong>通道</strong>的数据都必须先放到缓冲区中，同样，从<strong>通道</strong>中读取数据必须先读到缓冲区中。</p>
<h2 id="NIO的核心之缓冲区"><a href="#NIO的核心之缓冲区" class="headerlink" title="NIO的核心之缓冲区"></a>NIO的核心之缓冲区</h2><p>Buffer是一个对象，它包含一些要写入或者刚读出的数据。在NIO中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中，您将数据直接写入或者将数据直接读到Stream对象中。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。</p>
<p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>Java提供的多种Buffer类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>每一个 Buffer 类都是 Buffer 接口的一个实例。 除了 ByteBuffer，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 ByteBuffer，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p>
<h2 id="NIO的核心之通道"><a href="#NIO的核心之通道" class="headerlink" title="NIO的核心之通道"></a>NIO的核心之通道</h2><p>Channel是一个对象，可以通过它读取和写入数据。拿NIO与原来的I/O做个比较，通道就像是流。</p>
<p>正如前面所说的，所有数据都通过Buffer对象来处理。你永远不会将字节直接写入通道中，相反，你需要把数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<p><strong>通道</strong>与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道 可以用于读、写或者同时用于读写。</p>
<p>因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。</p>
<h1 id="NIO实践"><a href="#NIO实践" class="headerlink" title="NIO实践"></a>NIO实践</h1><p>首先看一个文件读取的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>);</div><div class="line">FileChannel fc = fin.getChannel();</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">fc.read(buffer);</div></pre></td></tr></table></figure>
<p>程序清楚的显示了读取文件的过程，首先创建一个输入流，然后从<code>FileInputStream</code>中获取一个通道，在创建一个buffer缓冲区，然后就可以通过缓冲区读取数据了。我们不需要告诉通道要读多少数据到缓冲区中。每一个缓冲区都有复杂的内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据，后面我们会对缓冲区内部机制进行更深分析。</p>
<p>然后看一个文件写入的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"writesomebytes.txt"</span> );</div><div class="line">FileChannel fc = fout.getChannel();</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;message.length; ++i) &#123;</div><div class="line">     buffer.put( message[i] );</div><div class="line">&#125;</div><div class="line">buffer.flip();</div></pre></td></tr></table></figure>
<p>和文件读取的例子大致相同，创建输出流，获取通道，创建缓冲区，put()方法用于向缓冲区输入数据。flip()方法让缓冲区可以将新读入的数据写入另一个通道。</p>
<p>当fc.read(buffer)返回-1时，表示数据已经读取完毕。接下来看一个如何把一个文件的内容复制到一个新的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileCopyNIO</span><span class="params">(String source, String target)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">try</span> (FileInputStream in = <span class="keyword">new</span> FileInputStream(source)) &#123;</div><div class="line">        <span class="keyword">try</span> (FileOutputStream out = <span class="keyword">new</span> FileOutputStream(target)) &#123;</div><div class="line">            FileChannel inChannel = in.getChannel();</div><div class="line">            FileChannel outChannel = out.getChannel();</div><div class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4096</span>);</div><div class="line">            <span class="keyword">while</span>(inChannel.read(buffer) != -<span class="number">1</span>) &#123;</div><div class="line">                buffer.flip();</div><div class="line">                outChannel.write(buffer);</div><div class="line">                buffer.clear();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的结合前面的写入和读取的例子来解释就很简单了，clear()是清理缓冲区中的数据的方法，在从输入通道读入缓冲区之前，我们调用 clear()方法来清理缓冲区的数据。</p>
<h2 id="缓冲区内部机制详解"><a href="#缓冲区内部机制详解" class="headerlink" title="缓冲区内部机制详解"></a>缓冲区内部机制详解</h2><p>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。</p>
<p>状态变量是前面提到的”内部统计机制”的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。</p>
<p>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用访问方法get()来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法put()。</p>
<p><strong>状态变量</strong></p>
<p>可以用三个值指定缓冲区在任意时刻的状态：</p>
<ul>
<li><code>position</code></li>
<li><code>limit</code></li>
<li><code>capacity</code></li>
</ul>
<p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。下面我们将详细分析每一个变量，还要介绍它们如何适应典型的读/写(输入/输出)进程。在这个例子中，我们假定要将数据从一个输入通道拷贝到一个输出通道。</p>
<p><strong>Position</strong></p>
<p>您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 position 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 position 将会设置为3，指向数组中第四个元素。</p>
<p>同样，在写入通道时，您是从缓冲区中获取数据。 position 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 position 将被设置为5，指向数组的第六个元素。</p>
<p><strong>Limit</strong></p>
<p><code>limit</code>变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。<br>position 总是小于或者等于 limit。</p>
<p><strong>Capacity</strong></p>
<p>缓冲区的<code>capacity</code>表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。<br><strong>注意</strong>：<code>limit</code> 决不能大于 <code>capacity。</code></p>
<h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>我们首先观察一个新创建的缓冲区。出于需要，我们假设这个缓冲区的<strong>总容量</strong>为8个字节。 Buffer 的状态如下所示：</p>
<p><img src="https://i.loli.net/2018/01/09/5a548450770c6.gif" alt="figure1.gif"></p>
<p>回想一下，limit决不能大于capacity，此例中这两个值都被设置为8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。</p>
<p><img src="https://i.loli.net/2018/01/09/5a5484507fdc3.gif" alt="figure2.gif"></p>
<p>position 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入slot0。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自slot0。position设置如下所示：</p>
<p><img src="https://i.loli.net/2018/01/09/5a54845087b13.gif" alt="figure3.gif"></p>
<h3 id="开始读取数据"><a href="#开始读取数据" class="headerlink" title="开始读取数据"></a>开始读取数据</h3><p>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从<code>position</code>开始的位置，这时<code>position</code>被设置为 0。读完之后，<code>position</code>就增加到3，如下所示：</p>
<p><img src="https://i.loli.net/2018/01/09/5a54845087b98.gif" alt="figure4.gif"></p>
<h3 id="再次读取数据"><a href="#再次读取数据" class="headerlink" title="再次读取数据"></a>再次读取数据</h3><p>我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由<code>position</code>所指定的位置上，position因而增加2：</p>
<p><img src="https://i.loli.net/2018/01/09/5a54845087b52.gif" alt="figure5.gif"></p>
<h3 id="输出数据到通道"><a href="#输出数据到通道" class="headerlink" title="输出数据到通道"></a>输出数据到通道</h3><p>还记得flip方法发，现在我们要将数据写到输出通道中。在这之前，我们必须调用flip()方法。这个方法做两件非常重要的事：</p>
<ul>
<li>它将<code>limit</code>设置为当前<code>position</code>。</li>
<li>它将<code>position</code>设置为0。<br>前面的图显示了在<code>flip</code>之前缓冲区的情况。下面是在<code>flip</code>之后的缓冲区：</li>
</ul>
<p><img src="https://i.loli.net/2018/01/09/5a548450881b2.gif" alt="figure6.gif"></p>
<p>我们现在可以将数据从缓冲区写入通道了。<code>position</code>被设置为0，这意味着我们得到的下一个字节是第一个字节。<code>limit</code>已被设置为原来的<code>position</code>，这意味着它包括以前读到的所有字节，并且一个字节也不多。</p>
<p><strong>初始写入</strong></p>
<p>在初始写入时，我们从缓冲区中取四个字节并将它们写入输出通道。这使得<code>position</code>增加到4，而<code>limit</code>不变，如下所示：</p>
<p><img src="https://i.loli.net/2018/01/09/5a54845088770.gif" alt="figure7.gif"></p>
<p><strong>最后一个写入</strong></p>
<p>我们只剩下一个字节可写了。<code>limit</code>在我们调用<code>flip()</code>时被设置为5，并且<code>position</code>不能超过<code>limit</code>。所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道。这使得<code>position</code>增加到5，并保持<code>limit</code>不变，如下所示：</p>
<p><img src="https://i.loli.net/2018/01/09/5a5484508c6f3.gif" alt="figure8.gif"></p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>最后一步是调用缓冲区的<code>clear()</code>方法。这个方法重设缓冲区以便接收更多的字节。<code>Clear</code>做两种非常重要的事情：<br>它将<code>limit</code>设置为与<code>capacity</code>相同。<br>它设置<code>position</code>为0。<br>下图显示了在调用<code>clear()</code>后缓冲区的状态：</p>
<p><img src="https://i.loli.net/2018/01/09/5a5484508c6f3.gif" alt="figure9.gif"></p>
<h1 id="回显服务器"><a href="#回显服务器" class="headerlink" title="回显服务器"></a>回显服务器</h1><p>在讲完 <code>NIO</code> 内部机制后，我们使用<code>Java NIO</code>来构建一个回显服务器，这个回显服务器使用<code>socket</code>监听接口，然后接收客户端的连接，然后把客户端发过来的数据原封不动的发回去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">Selector selector = Selector.open();</div><div class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</div><div class="line">ssc.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">ServerSocket ss = ssc.socket();</div><div class="line"><span class="comment">//        InetSocketAddress address = new InetSocketAddress( ports[i] );</span></div><div class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">12345</span>);</div><div class="line">ss.bind(address);</div><div class="line">SelectionKey selectionKey = ssc.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line">ByteBuffer echoBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">int</span> num = selector.select();</div><div class="line"></div><div class="line">    Set selectedKeys = selector.selectedKeys();</div><div class="line">    Iterator it = selectedKeys.iterator();</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">        SelectionKey key = (SelectionKey) it.next();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</div><div class="line">                == SelectionKey.OP_ACCEPT) &#123;</div><div class="line">            <span class="comment">// Accept the new connection</span></div><div class="line">            ServerSocketChannel ssc2 = (ServerSocketChannel) key.channel();</div><div class="line">            SocketChannel sc = ssc2.accept();</div><div class="line">            sc.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            <span class="comment">// Add the new connection to the selector</span></div><div class="line">            SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ);</div><div class="line">            it.remove();</div><div class="line"></div><div class="line">            System.out.println(<span class="string">"Got connection from "</span> + sc);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ)</div><div class="line">                == SelectionKey.OP_READ) &#123;</div><div class="line">            <span class="comment">// Read the data</span></div><div class="line">            SocketChannel sc = (SocketChannel) key.channel();</div><div class="line">            <span class="comment">// Echo data</span></div><div class="line">            <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                echoBuffer.clear();</div><div class="line">                <span class="keyword">int</span> r;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    r = sc.read(echoBuffer);</div><div class="line">                    <span class="keyword">int</span> count = sc.read(echoBuffer);</div><div class="line">                     <span class="keyword">if</span> (r &lt; <span class="number">0</span>)&#123;</div><div class="line">                        key.cancel();</div><div class="line">                        sc.close();</div><div class="line">                        System.out.println(<span class="string">"cancel key for &lt; 0"</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e)&#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                    key.cancel();</div><div class="line">                    System.out.println(<span class="string">"cancel key for Exception"</span>);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                echoBuffer.flip();</div><div class="line"></div><div class="line">                sc.write(echoBuffer);</div><div class="line">                bytesEchoed += r;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            System.out.println(<span class="string">"Echoed "</span> + bytesEchoed + <span class="string">" from "</span> + sc);</div><div class="line"></div><div class="line">            it.remove();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(<span class="string">"going to clear"</span>);</div><div class="line">    selectedKeys.clear();</div><div class="line">    System.out.println(<span class="string">"cleared"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是一个使用<code>select</code>模型和<code>NIO</code>构建的一个简单服务器，它监听服务器的<code>12345</code>端口，当客户端连接到<code>12345</code>端口时，它会建立与客户端的连接，并且可以把客户端的消息原封不动的发送回去，你可以使用多个客户端与服务器建立连接，服务器也可以正确的把消息返回给你，<code>注意：服务器一直使用一个进程来建立连接，它没有建立新的进程，因此也就没有进程或者线程切换所带来的消耗！</code>，在大量的客户端同时与服务器建立连接是他才能显示出威力，如果没有大量的连接，建议还是使用普通的多线程或者多进程服务器，因为它们比较简单，性能也没有太大区别。</p>
<h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>在我们边写的程序中，使用的Selector对象使用程序的核心，它是我们注册对各种<code>IO</code>事件感兴趣的地方，当有<code>IO</code>事件发生时，这个对象会告诉我们所发生的事件，</p>
<p><code>Selector selector = Selector.open();</code>用于创建一个Selector对象，你可以将不同的通道对象注册到selector中，方法就是通道自身的<code>register</code>方法，参数是Selector类的的实例和你感兴趣的事件。</p>
<h2 id="注册ServerSocketChannel到Selector上"><a href="#注册ServerSocketChannel到Selector上" class="headerlink" title="注册ServerSocketChannel到Selector上"></a>注册ServerSocketChannel到Selector上</h2><p>首先我们打开一个<code>ServerSocketChannel</code>对象，并且把它绑定到通信的端口上，注意把这个对象设置为<strong>非阻塞的</strong>，这个非常重要，如果没有设置的话，可能程序无法工作。</p>
<p>第二步是把这个<code>ServerSocketChannel</code>对象注册到创建的Selector对象上，如代码所示。调用<code>register</code>方法后，会返回一个<code>SelectionKey</code>,它代表通道在<code>Selector</code>的注册，当发生相应的传入事件时，他是通过返回对应的<code>SelectionKey</code>来进行的，当你需要取消通道的注册时，可以通过<code>SelectionKey.cancel()</code>方法来取消。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</div><div class="line">ssc.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">ServerSocket ss = ssc.socket();</div><div class="line"><span class="comment">//        InetSocketAddress address = new InetSocketAddress( ports[i] );</span></div><div class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">12345</span>);</div><div class="line">ss.bind(address);</div><div class="line">SelectionKey selectionKey = ssc.register(selector, SelectionKey.OP_ACCEPT);</div></pre></td></tr></table></figure>
<h2 id="循环监听连接"><a href="#循环监听连接" class="headerlink" title="循环监听连接"></a>循环监听连接</h2><p>可以调用<code>Selector</code>的<code>select()</code>方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时，<code>select()</code> 方法将返回所发生的事件的数量。</p>
<p>然后你可以获取他的一个迭代器，通过迭代器并依次处理每个<code>SelectionKey</code>来处理事件。对于每一个<code>SelectionKe</code>，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">int</span> num = selector.select();</div><div class="line"></div><div class="line">    Set selectedKeys = selector.selectedKeys();</div><div class="line">    Iterator it = selectedKeys.iterator();</div><div class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">    SelectionKey key = (SelectionKey) it.next();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</div><div class="line">            == SelectionKey.OP_ACCEPT) &#123;</div></pre></td></tr></table></figure>
<h2 id="创建新的连接"><a href="#创建新的连接" class="headerlink" title="创建新的连接"></a>创建新的连接</h2><p>当发生<code>SelectionKey.OP_ACCEPT</code>事件时，代表有一个连接将要建立，我们可以直接调用<code>accept</code>接受这个连接，这里不会阻塞，因为我们知道有一个连接来了，当然不会阻塞，创建完连接后把连接注册到我们的<code>Selector</code>上，并设置对应的监听事件。<code>注意：这个连接也需要设置为非阻塞的。</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannel ssc2 = (ServerSocketChannel) key.channel();</div><div class="line">SocketChannel sc = ssc2.accept();</div><div class="line">sc.configureBlocking(<span class="keyword">false</span>);</div><div class="line">SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ);</div><div class="line">it.remove();</div></pre></td></tr></table></figure>
<h2 id="删除处理完的SelectionKey"><a href="#删除处理完的SelectionKey" class="headerlink" title="删除处理完的SelectionKey"></a>删除处理完的SelectionKey</h2><p>在处理完<code>SelectionKey</code>对应的事件后，我们需要删除它，如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的<code>remove()</code>方法来删除处理过的<code>SelectionKey</code>。</p>
<h2 id="继续循环…"><a href="#继续循环…" class="headerlink" title="继续循环…"></a>继续循环…</h2><p>每次返回主循环，我们都要调用<code>select</code>的<code>Selector()</code>方法，并取得一组<code>SelectionKey</code>。每个键代表一个<code>I/O</code>事件。我们处理事件，从选定的键集中删除<code>SelectionKey</code>，然后返回主循环的顶部。</p>
<h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><p>还有需要注意的一个点是代码中的这个部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span>)&#123;</div><div class="line">    key.cancel();</div><div class="line">    sc.close();</div><div class="line">    System.out.println(<span class="string">"cancel key for &lt; 0"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有的人可能会把它写成像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (r &lt;= <span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个是不正确的，当客户端粗暴的关闭连接时，服务器也应该关闭连接，如果没有关闭连接的话，在每次<code>selectedKeys.iterator</code>返回的时候都会返回当前<code>socket</code>可读的事件，这样会浪费服务器的资源，做不必要的操作。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好了，这篇文章我们着重讲了NIO库的使用以及内部特性，在一些新特性（例如文件锁定和字符集）提供新功能的同时，许多特性在优化方面也非常优秀。</p>
<p>在基础层次上，通道和缓冲区可以做的事情几乎都可以用原来的面向流的类来完成。但是通道和缓冲区允许以快得多的方式完成这些相同的旧操作 ― 事实上接近系统所允许的最大速度。</p>
<p>不过<code>NIO</code>最强大的长度之一在于，它提供了一种在<code>Java</code>语言中执行进行输入/输出的新的（也是迫切需要的）结构化方式。随诸如缓冲区、通道和异步<code>IO</code>这些概念性（且可实现的）实体而来的，是我们重新思考<code>Java</code>程序中的<code>IO</code>过程的机会。这样，<code>NIO</code>甚至为我们最熟悉的<code>IO</code>过程也带来了新的活力，同时赋予我们通过和以前不同并且更好的方式执行它们的机会。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="external">Java NIO浅析</a></li>
<li><a href="https://en.wikipedia.org/wiki/New_I/O_Java" target="_blank" rel="external">New I/O (Java)</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Servlet/" rel="tag"># Servlet</a>
          
            <a href="/tags/IO/" rel="tag"># IO</a>
          
            <a href="/tags/异步事件模型/" rel="tag"># 异步事件模型</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/02/JavaIO-overview/" rel="next" title="Java IO概述">
                <i class="fa fa-chevron-left"></i> Java IO概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/12/Linux-select、poll、epoll/" rel="prev" title="Linux select、poll、epoll模式详解">
                Linux select、poll、epoll模式详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

    
      <div id="gitment"></div>

<!-- 主页不要加载gitment -->

<!--  id: '<%= page.title %>' -->
<script>
var gitment = new Gitment({
  id: location.href,
  owner: 'heshangbuxitou',
  repo: 'heshangbuxitou.github.io',
  oauth: {
    client_id: '14715ee89ca1af10566d',
    client_secret: '0b809ebdd2c4d75410f4ef8237f0815d0f2b5484',
  },
})
gitment.render('gitment')

</script>

  
    

    </footer>
  </div>
  
  
  
  </article>








    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/myavatar.gif"
                alt="SiYuYong" />
            
              <p class="site-author-name" itemprop="name">SiYuYong</p>
              <p class="site-description motion-element" itemprop="description">胡编一通，乱写一气</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/heshangbuxitou" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:siyuyon@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://heyanfu.github.io/" title="何神的博客" target="_blank" rel="external nofollow">何神的博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#了解Java-NIO"><span class="nav-number">1.</span> <span class="nav-text">了解Java NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO带来的好处"><span class="nav-number">1.1.</span> <span class="nav-text">NIO带来的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO与传统的IO有什么不同"><span class="nav-number">1.2.</span> <span class="nav-text">NIO与传统的IO有什么不同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO的核心"><span class="nav-number">2.</span> <span class="nav-text">NIO的核心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO的核心之缓冲区"><span class="nav-number">2.1.</span> <span class="nav-text">NIO的核心之缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO的核心之通道"><span class="nav-number">2.2.</span> <span class="nav-text">NIO的核心之通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO实践"><span class="nav-number">3.</span> <span class="nav-text">NIO实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区内部机制详解"><span class="nav-number">3.1.</span> <span class="nav-text">缓冲区内部机制详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始状态"><span class="nav-number">3.1.1.</span> <span class="nav-text">初始状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始读取数据"><span class="nav-number">3.1.2.</span> <span class="nav-text">开始读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再次读取数据"><span class="nav-number">3.1.3.</span> <span class="nav-text">再次读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出数据到通道"><span class="nav-number">3.1.4.</span> <span class="nav-text">输出数据到通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结尾"><span class="nav-number">3.1.5.</span> <span class="nav-text">结尾</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#回显服务器"><span class="nav-number">4.</span> <span class="nav-text">回显服务器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码详解"><span class="nav-number">5.</span> <span class="nav-text">代码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector"><span class="nav-number">5.1.</span> <span class="nav-text">Selector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注册ServerSocketChannel到Selector上"><span class="nav-number">5.2.</span> <span class="nav-text">注册ServerSocketChannel到Selector上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环监听连接"><span class="nav-number">5.3.</span> <span class="nav-text">循环监听连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建新的连接"><span class="nav-number">5.4.</span> <span class="nav-text">创建新的连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除处理完的SelectionKey"><span class="nav-number">5.5.</span> <span class="nav-text">删除处理完的SelectionKey</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继续循环…"><span class="nav-number">5.6.</span> <span class="nav-text">继续循环…</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特殊情况"><span class="nav-number">6.</span> <span class="nav-text">特殊情况</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结束"><span class="nav-number">7.</span> <span class="nav-text">结束</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SiYuYong</span>

  
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
